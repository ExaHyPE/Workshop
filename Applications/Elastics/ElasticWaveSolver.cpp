// This file was generated by the ExaHyPE toolkit.
// It will NOT be regenerated or overwritten.
// Please adapt it to your own needs.
// 
// ========================
//   www.exahype.eu
// ========================

#include "ElasticWaveSolver.h"

#include "ElasticWaveSolver_Variables.h"

#include "kernels/KernelUtils.h"
#include "peano/utils/Loop.h"

tarch::logging::Log Linear::ElasticWaveSolver::_log( "Linear::ElasticWaveSolver" );


void Linear::ElasticWaveSolver::init(const std::vector<std::string>& cmdlineargs,const exahype::parser::ParserView& constants) {
  initPointSourceLocations(cmdlineargs,constants);	
}

void Linear::ElasticWaveSolver::adjustPointSolution(const double* const x,const double t,const double dt,double* const Q) {
  VariableShortcuts s;
  if (tarch::la::equals(t,0.0)) {
    //    double r2 = (x[0]-5.0)*(x[0]-5.0) + (x[1]-5.0)*(x[1]-5.0);
    //    Q[s.v + 0]     = exp(-r2);
    //    Q[s.v + 1]     = exp(-r2);
    Q[s.v + 0]     = 0.0;
    Q[s.v + 1]     = 0.0;    
    Q[s.sigma + 0] = 0.0;
    Q[s.sigma + 1] = 0.0;
    Q[s.sigma + 2] = 0.0;
    Q[s.rho]       = 2.7;
    Q[s.cp]        = 6.0;
    Q[s.cs]        = 3.343;
  }
}

void Linear::ElasticWaveSolver::boundaryValues(const double* const x,const double t,const double dt,const int faceIndex,const int direction,const double* const fluxIn,const double* const stateIn,const double* const gradStateIn,double* const fluxOut,double* const stateOut) {
  
  int normal_velocity, tangent_velocity;
  int normal_traction, tangent_traction;
  VariableShortcuts s;

  if (direction == 0){
    normal_velocity  = s.v + 0;
    normal_traction = s.sigma + 0;
    tangent_velocity  = s.v + 1;
    tangent_traction = s.sigma + 1;
  }else{
    normal_velocity  = s.v + 1;
    normal_traction = s.sigma + 1;
    tangent_velocity  = s.v + 0;
    tangent_traction = s.sigma + 0;
  }

  //abc
  stateOut[normal_velocity] = 0;
  stateOut[tangent_velocity] = 0;
  stateOut[normal_traction] = 0;
  stateOut[tangent_traction] = stateIn[tangent_traction];
  stateOut[4] = 0;
  stateOut[5] = stateIn[5];
  stateOut[6] = stateIn[6];
  stateOut[7] = stateIn[7];


  stateOut[normal_velocity] = 0;
  stateOut[tangent_velocity] = 0;
  stateOut[normal_traction] = 0;
  stateOut[tangent_traction] = 0;
  stateOut[4] = 0;
  stateOut[5] = stateIn[5];
  stateOut[6] = stateIn[6];
  stateOut[7] = stateIn[7];


  fluxOut[0] = 0.0;
  fluxOut[1] = 0.0;
  fluxOut[2] = 0.0;
  fluxOut[3] = 0.0;
  fluxOut[4] = 0.0;
}

exahype::solvers::Solver::RefinementControl Linear::ElasticWaveSolver::refinementCriterion(const double* const luh,const tarch::la::Vector<DIMENSIONS,double>& cellCentre,const tarch::la::Vector<DIMENSIONS,double>& cellSize,double t,const int level) {
  
  return exahype::solvers::Solver::RefinementControl::Keep;
  
}

//*****************************************************************************
//******************************** PDE ****************************************
// To use other PDE terms, specify them in the specification file, delete this 
// file and its header and rerun the toolkit
//*****************************************************************************


void Linear::ElasticWaveSolver::eigenvalues(const double* const Q,const int direction,double* const lambda) {
  VariableShortcuts s;

  lambda[0] =  Q[s.cp];
  lambda[1] =  Q[s.cs];
  lambda[2] =  0.0;
  lambda[3] = -Q[s.cs];
  lambda[4] = -Q[s.cp];
}



void Linear::ElasticWaveSolver::flux(const double* const Q,double** const F) {

  VariableShortcuts s;

  double sxx = Q[s.sigma + 0];
  double syy = Q[s.sigma + 1];
  double sxy = Q[s.sigma + 2];
    
  F[0][0] = -sxx;
  F[0][1] = -sxy;
  F[0][2] =  0.0;
  F[0][3] =  0.0;
  F[0][4] =  0.0;
  
  F[1][0] = -sxy;
  F[1][1] = -syy;
  F[1][2] =  0.0;
  F[1][3] =  0.0;
  F[1][4] =  0.0;  
}



void  Linear::ElasticWaveSolver::nonConservativeProduct(const double* const Q,const double* const * const gradQ,double** const BgradQ) {

  VariableShortcuts s;

  double u_x = gradQ[0][s.v + 0];
  double v_x = gradQ[0][s.v + 1];
  double u_y = gradQ[1][s.v + 0];
  double v_y = gradQ[1][s.v + 1];

  BgradQ[0][0] =  0.0;
  BgradQ[0][1] =  0.0;
  BgradQ[0][2] = -u_x;
  BgradQ[0][3] =  0.0;
  BgradQ[0][4] = -v_x;
  
  BgradQ[1][0] =  0.0;
  BgradQ[1][1] =  0.0;
  BgradQ[1][2] =  0.0;
  BgradQ[1][3] = -v_y;
  BgradQ[1][4] = -u_y;
}


void  Linear::ElasticWaveSolver::initPointSourceLocations(const std::vector<std::string>& cmdlineargs,const exahype::parser::ParserView& constants){
  pointSourceLocation[0][0]=5.0;
  pointSourceLocation[0][1]=5.0;
}

void  Linear::ElasticWaveSolver::pointSource(const double* const Q,const double* const x,const double t,const double dt, double* const forceVector, int n) {

  VariableShortcuts s;
  double pi = 3.14159265359;
  double sigma = 0.1149;
  double t0 = 0.7;
  double f = 0.0;
  double M0 = 1000.0;

  f = (1.0/(sigma*std::sqrt(2.0*pi)))*(std::exp(-((t-t0)*(t-t0))/(2.0*sigma*sigma)));

  forceVector[0] = 0.0;
  forceVector[1] = 0.0;
  forceVector[2] = f;
  forceVector[3] = f;
  forceVector[4] = 0.0;
}

void Linear::ElasticWaveSolver::multiplyMaterialParameterMatrix(const double* const Q, double** const rhs) {
  VariableShortcuts s;

  const double rho  = Q[s.rho];
  const double cp   = Q[s.cp];   
  const double cs   = Q[s.cs];

  const double mu  = rho*cs*cs;
  const double lambda = rho*cp*cp-2.0*mu;  

  for (int d = 0 ; d< DIMENSIONS ; d++){
    rhs[d][0] = 1.0/rho*rhs[d][0];
    rhs[d][1] = 1.0/rho*rhs[d][1];
    
    double rhs_2 = (2*mu+lambda)*rhs[d][2] + lambda*rhs[d][3];
    double rhs_3 = (2*mu+lambda)*rhs[d][3] + lambda*rhs[d][2];
    
    rhs[d][2] = rhs_2;
    rhs[d][3] = rhs_3;
    
    rhs[d][4] = mu * rhs[d][4];
  }

}
