// This file was generated by the ExaHyPE toolkit.
// It will NOT be regenerated or overwritten.
// Please adapt it to your own needs.
// 
// ========================
//   www.exahype.eu
// ========================

#include "AcousticWaveSolver.h"

#include "AcousticWaveSolver_Variables.h"

#include "kernels/KernelUtils.h"
#include "peano/utils/Loop.h"

tarch::logging::Log Linear::AcousticWaveSolver::_log( "Linear::AcousticWaveSolver" );


void Linear::AcousticWaveSolver::init(const std::vector<std::string>& cmdlineargs,const exahype::parser::ParserView& constants) {
  initPointSourceLocations(cmdlineargs,constants);	
}

void Linear::AcousticWaveSolver::adjustPointSolution(const double* const x,const double t,const double dt,double* const Q) {
  VariableShortcuts s;
  if (tarch::la::equals(t,0.0)) {
    Q[s.p    ] = 0.0;
    Q[s.v + 0] = 0.0;
    Q[s.v + 1] = 0.0;
    Q[s.rho]       = 2.7;
    Q[s.c]        = 6.0;
  }
}

void Linear::AcousticWaveSolver::boundaryValues(const double* const x,const double t,const double dt,const int faceIndex,const int direction,const double* const fluxIn,const double* const stateIn,const double* const gradStateIn,double* const fluxOut,double* const stateOut) {

  //abc  
  stateOut[0] =  0;
  stateOut[1] =  0;
  stateOut[2] =  0;
  stateOut[3] =  stateIn[3];
  stateOut[4] =  stateIn[4];
}

exahype::solvers::Solver::RefinementControl Linear::AcousticWaveSolver::refinementCriterion(const double* const luh,const tarch::la::Vector<DIMENSIONS,double>& cellCentre,const tarch::la::Vector<DIMENSIONS,double>& cellSize,double t,const int level) {
  return exahype::solvers::Solver::RefinementControl::Keep;
}

//*****************************************************************************
//******************************** PDE ****************************************
// To use other PDE terms, specify them in the specification file, delete this 
// file and its header and rerun the toolkit
//*****************************************************************************


void Linear::AcousticWaveSolver::eigenvalues(const double* const Q,const int direction,double* const lambda) {
  VariableShortcuts s;
  double c = Q[s.c];

  lambda[0] =   c;
  lambda[1] =  -c;
  lambda[2] = 0.0;
}

void Linear::AcousticWaveSolver::flux(const double* const Q,double** const F) {
  VariableShortcuts s;

  double rho    = Q[s.rho];
  double c      = Q[s.c];
  double K_0    = rho*c*c;
  
  F[0][0] = -K_0 * Q[s.v + 0];
  F[0][1] = -1/rho * Q[s.p];
  F[0][2] =               0.0;
  
  F[1][0] = -K_0 * Q[s.v + 1];
  F[1][1] =               0.0;
  F[1][2] = -1/rho * Q[s.p];  
}

void  Linear::AcousticWaveSolver::initPointSourceLocations(const std::vector<std::string>& cmdlineargs,const exahype::parser::ParserView& constants){
  pointSourceLocation[0][0] = 5.0;
  pointSourceLocation[0][1] = 5.0;
}

void  Linear::AcousticWaveSolver::pointSource(const double* const Q,const double* const x,const double t,const double dt, double* const forceVector, int n) {
  VariableShortcuts s;
  double pi = 3.14159265359;
  double sigma = 0.1149;
  double t0 = 0.7;
  double f = 0.0;
  double M0 = 1000.0;

  f = M0*std::exp(-((t-t0)*(t-t0))/(2.0*sigma*sigma));

  forceVector[s.p    ] = f;
  forceVector[s.v + 0] = 0.0;
  forceVector[s.v + 1] = 0.0;
}
